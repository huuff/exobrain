# The low cohesion of Kubernetes
There's an important drive behind Kubernetes of reducing complexity by reducing coupling. Everything in the Kubernetes system is really decoupled. However, coupling and cohesion go hand-in-hand, and this seems to have made Kubernetes lose a lot of cohesion.

## A million control loops
Instead of a defined orchestration workflow, Kubernetes is made of a lot of tiny control loops that try to reconcile small parts of the system, then, when all of those click together, the deployment works as intended. However, when something goes wrong, it's really complex chasing down what is making the deployment fail. Kubernetes doesn't know anything other than whether something is running, how many replicas, etc. it has, but any control loop might fail and you'll have to check them (in the worst case, all logs one by one) to see which one is the culprit (or worse, it's the interaction or lack of it what makes it go wrong). To quote [A better Kubernetes, from the ground up](https://blog.dave.tf/post/new-kubernetes/)

> The biggest issue I have with the “API machinery” bits of Kubernetes is the idea of orchestration as a loose choreography of independent control loops. On the surface, this seems like a nice idea: you have dozens of little control loops, each focused on doing one small thing. When combined in a cluster, they indirectly cooperate with each other to push the state forward and converge on the desired end state. So, what’s the problem?  
The problem is that it’s entirely impossible to debug when it goes wrong. A typical failure mode in Kubernetes is that you submit a change to the cluster, then repeatedly refresh waiting for stuff to converge. When it doesn’t… Well, you’re screwed. Kubernetes doesn’t know the difference between “the system has converged successfully” and “a control loop is wedged and is blocking everything else.” You can hope that the offending control loop posted some events to the object to help you, but by and large they don’t.  
At which point your only option is to cat the logs of every control loop that might be involved, looking for the one that was wedged. You can make this a bit faster if you have intimate knowledge of all the control loops and what each one does, because that lets you infer from the object’s current state which loop might be trying to run right now.

## Features are provided by many small parts
This makes it much moe complex to know which features are available, or even worse, you can use a feature without knowing it's not working! You have to install the [[crd]] and you have to install the [[operator]]s, without the operator or controller, the CRDs are useless. Of course you can post them, get them, delete them, but they won't be used by anything! Some tools like [[helm]] can help to alleviate this, but it might become an issue.

Another example is networking with [[flannel]]. Flannel has no network policies, but you might just define them without knowing they aren't being enforced. Especially with security features, this becomes dangerous
