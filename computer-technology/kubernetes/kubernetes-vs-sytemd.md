---
tags: comparison
---

# Kubernetes vs `systemd`
Having used both Kubernetes for orchestrating Docker containers and `systemd` for [[nixos-container]]s, I found some things a little more wonky in Kubernetes. I couldn't manage to find out what it was but the following article (which I loved) puts it perfectly: [A better Kubernetes, from the ground up](https://blog.dave.tf/post/new-kubernetes/)

> The biggest issue I have with the “API machinery” bits of Kubernetes is the idea of orchestration as a loose choreography of independent control loops. On the surface, this seems like a nice idea: you have dozens of little control loops, each focused on doing one small thing. When combined in a cluster, they indirectly cooperate with each other to push the state forward and converge on the desired end state. So, what’s the problem?  
The problem is that it’s entirely impossible to debug when it goes wrong. A typical failure mode in Kubernetes is that you submit a change to the cluster, then repeatedly refresh waiting for stuff to converge. When it doesn’t… Well, you’re screwed. Kubernetes doesn’t know the difference between “the system has converged successfully” and “a control loop is wedged and is blocking everything else.” You can hope that the offending control loop posted some events to the object to help you, but by and large they don’t.  
At which point your only option is to cat the logs of every control loop that might be involved, looking for the one that was wedged. You can make this a bit faster if you have intimate knowledge of all the control loops and what each one does, because that lets you infer from the object’s current state which loop might be trying to run right now.
> The key thing to notice here is that the complexity has been shifted from the designer of the control loop to the cluster operator. It’s easy (though not trivial) to make a control loop that does a dinky little thing in isolation. But to operate a cluster with dozens of these control loops requires the operator to assimilate the behavior of all of them, their interactions with each other, and try to reason about an extremely loosely coupled system. This is a problem because you have to write and test the control loop once, but work with it and its bugs many more times. And yet, the bias is to simplify the thing you only do once.  
> To fix this, I would look to systemd. It solves for a similar lifecycle problem: given a current state and a target, how do you get from A to B? The difference is that in systemd, the steps and their dependencies are made explicit. You tell systemd that your unit is a required part of multi-user.target (aka “normally-booted happy system”), that it must run after filesystems have been mounted, but before networking it brought up, and so forth. You can also depend on other concrete parts of the system, for example to say that your thing needs to run whenever sshd is running (sounds like a sidecar, right?).  
> The net result of this is that systemd can tell you precisely what piece of the system malfunctioned, or is still working on its thing, or failed a precondition. It can also print you a graph of the system’s boot process, and analyze it for things like “what’s the long pole of bootup?”  
> I want to steal all this wholesale, and plop it into my cluster orchestration system. It does need some adjusting to this new world, but roughly: control loops must declare their dependencies on other control loops, must produce structured logs such that I can trivially search for “all control loop activity regarding pod X”, and the orchestration system handles lifecycle events like systemd handles switching to a new target unit.  
> What does that look like in practice? Let’s focus on pod lifecycle. Probably we’ll define an abstract “running” target, which is where we want to end up - the pod has started and is happy. Working backwards, the container runtime will add a task that happens before “running”, to start the containers. But it should probably not run until storage systems have had a chance to set up networked mounts, so it’ll order itself after a “storage” target. Similarly for networking, container startup wants to happen after the “networking” target.  
> Now your Ceph control loop schedules itself to run before the “storage” target, since it’s responsible for bringing up the storage. Other storage control loops do the same (local bind mount, NFS, …). Note this means their setups can run concurrently, because they all declare that they want to run before storage is considered ready, but don’t care if they run before or after other stuff. Or maybe they do care! Maybe you wrote a cool storage addon that does something amazing, but NFS mounting has to happen before you can execute. Cool, that’s fine, add a dependency on the nfs-mounts step, and you’re done. Like systemd, we would have both ordering requirements and hard “I need this other thing to function at all” requirements, so you can have graceful optional ordering of steps.  
> (I’m simplifying a little here and assuming the steps aren’t too intertwined. This generalizes to a more complex flow if needed - but see sections further down about working hard to avoid the need for very complex flows in the first place.)  
> With this in place, your orchestrator can help you answer “why isn’t my pod starting?” You can simply dump the work graph for the pod, and see which steps have completed, which have failed, which are still running. NFS mounting has been going for 5 minutes? I’m guessing the server’s down and the control loop is missing a timeout. Going back to the observation about the matrix of possible configurations and states being immense: that can be okay, if you provide the tools to debug it. Systemd allows you to add arbitrary anythings to the boot process, in any order, with any constraints. But I can still troubleshoot it when it goes wrong, because the constraints it does have combined with the tooling it offers let me quickly make sense of a particular machine from first principles.  
> Similar to the benefit systemd brings to system startup, this also lets you parallelize lifecycle operations as aggressively as they can be, but no more. And because the workflow graph is explicit, it’s extensible. Does your cluster have some company-specific step that happens for every pod, and must happen at a specific place in the lifecycle? Define a new intermediate target for that, make it depend on the right pre- and post-requisites, and hook your control loop on there. The orchestration system will ensure that your control loop always gets involved at exactly the right point in the lifecycle.  
> Note this also fixes the weirdness with things like Istio, where they have to hackily inject themselves into the human-provided definition in order to function. There’s no need for that! Insert the appropriate control loops into the lifecycle graph, and have it adjust things as needed on the inside. No need to muck with operator-provided objects, as long as you can express to the system where in the lifecycle you need to do stuff.
